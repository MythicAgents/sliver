import pathlib
import asyncio
from mythic_container.PayloadBuilder import *
from mythic_container.MythicCommandBase import *
from mythic_container.MythicRPC import *

from ..utils.sliver_connect import connect_and_store_sliver_client, connect_and_store_sliver_interact

service_started = False

class SliverImplant(PayloadType):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # This class is instantiated during start_and_run_forever, as well as when payloads are generated
        # When the service first starts up, it should re-create the sliver clients (and sync callbacks from sliver into Mythic)
        global service_started
        if (not service_started):
            service_started = True
            asyncio.create_task(recreate_sliver_clients_and_sync())

    name = "sliverimplant"
    author = "Spencer Adolph"
    note = "A sliver generated implant. The implant's C2 is external to Mythic, and relies on a sliverserver payload for tasking."
    supported_os = [SupportedOS.Windows, SupportedOS.Linux, SupportedOS.MacOS]
    file_extension = ""
    wrapper = False
    wrapped_payloads = []
    supports_dynamic_loading = False
    c2_profiles = []
    mythic_encrypts = False
    translation_container = None
    agent_path = pathlib.Path(".") / "sliverimplant"
    agent_icon_path = agent_path / "sliver.svg"
    agent_code_path = agent_path / "agent_code"
    build_steps = []
    build_parameters = [
        BuildParameter(
            name="configfile_id",
            description="Sliver Operator Config FileId",
            parameter_type=BuildParameterType.String,
        ),
    ]

    async def build(self) -> BuildResponse:
        filecontent = await SendMythicRPCFileGetContent(MythicRPCFileGetContentMessage(
            AgentFileId=self.get_parameter('configfile_id')
        ))
        await connect_and_store_sliver_client(self.get_parameter('configfile_id'), filecontent.Content)
        await connect_and_store_sliver_interact(self.get_parameter('configfile_id'), self.uuid)

        resp = BuildResponse(status=BuildStatus.Success)
        return resp

async def recreate_sliver_clients_and_sync():
    payload_search_results = await SendMythicRPCPayloadSearch(MythicRPCPayloadSearchMessage(
        CallbackID=1,
        IncludeAutoGeneratedPayloads=True,
        PayloadTypes=['sliverimplant']
    ))

    for sliverimplant_payload in payload_search_results.Payloads:
        # check if already 'disconnected' as far as Mythic knows, if so, don't create the sliver client + interact
        callbacks = await SendMythicRPCCallbackSearch(MythicRPCCallbackSearchMessage(
            AgentCallbackID=1,
            SearchCallbackExtraInfo=sliverimplant_payload.UUID
        ))
        if (callbacks.Results[0].IntegrityLevel == -1):
            continue

        # mythic thinks connected, connect to sliver using config file, and attempt to create the 'interact'
        filecontent = await SendMythicRPCFileGetContent(MythicRPCFileGetContentMessage(
            AgentFileId=sliverimplant_payload.BuildParameters[0].Value
        ))
        await connect_and_store_sliver_client(sliverimplant_payload.BuildParameters[0].Value, filecontent.Content)
        interact = await connect_and_store_sliver_interact(sliverimplant_payload.BuildParameters[0].Value, sliverimplant_payload.UUID)

        if (interact == None):
            # mythic thought connected, sliver now saying 'disconnected', update the callback
            await SendMythicRPCCallbackUpdate(MythicRPCCallbackUpdateMessage(
                CallbackID=callbacks.Results[0].ID,
                Description='disconnected!',
                IntegrityLevel=-1,
            ))

